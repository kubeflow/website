+++
title = "Connect the Pipelines SDK to Kubeflow Pipelines"
description = "How to connect the Pipelines SDK to Kubeflow Pipelines in various ways"
weight = 25
+++

How you connect the Pipelines SDK to Kubeflow Pipelines will depend on what type of Kubeflow deployment you have, and where you are running your code:

* [Standalone Kubeflow (from inside cluster)](#standalone-kubeflow-from-inside-cluster)
* [Standalone Kubeflow (from outside cluster)](#standalone-kubeflow-from-outside-cluster)
* [Multi-user Kubeflow (from inside cluster)](#multi-user-kubeflow-from-inside-cluster)
* [Multi-user Kubeflow (from outside cluster)](#multi-user-kubeflow-from-outside-cluster)

## Standalone Kubeflow (from inside cluster)

{{% alert title="Warning" color="warning" %}}
This will only work for standalone Kubeflow Pipelines, for multi-user Kubeflow see [Multi-user Kubeflow (from inside cluster)](#multi-user-kubeflow-from-inside-cluster).
{{% /alert %}}

In [standalone deployments](/docs/components/pipelines/installation/standalone-deployment/) of Kubeflow Pipelines, there is no authentication enforced on the `ml-pipeline-ui` service.

To authenticate the Pipelines SDK from inside the cluster in standalone mode, you may use the [DNS names](https://kubernetes.io/docs/concepts/services-networking/service/#discovering-services) that are automatically generated by Kubernetes.

For example, when running in the __same namespace__ as Kubeflow:

```python
import kfp

client = kfp.Client(host="http://ml-pipeline-ui:80")

print(client.list_experiments())
```

For example, when running in a __different namespace__ to Kubeflow:

```python
import kfp

# the namespace in which you deployed Kubeflow Pipelines
namespace = "kubeflow" 

client = kfp.Client(host=f"http://ml-pipeline-ui.{namespace}")

print(client.list_experiments())
```


## Standalone Kubeflow (from outside cluster)

{{% alert title="Warning" color="warning" %}}
This will only work for standalone Kubeflow Pipelines, for multi-user Kubeflow see [Multi-user Kubeflow (from outside cluster)](#multi-user-kubeflow-from-outside-cluster).
{{% /alert %}}

In [standalone deployments](/docs/components/pipelines/installation/standalone-deployment/) of Kubeflow Pipelines, there is no authentication enforced on the `ml-pipeline-ui` service.

To authenticate the Pipelines SDK from outside the cluster in standalone mode, you may use [port-forwarding](https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/) on the `ml-pipeline-ui` service.

First, run the following command on your external system to initiate port-forwarding:

```bash
# change `--namespace` if you deployed Kubeflow Pipelines into a different namespace
kubectl port-forward --namespace kubeflow svc/ml-pipeline-ui 3000:80
```

Second, the following code will create a `kfp.Client()` against your port-forwarded `ml-pipeline-ui` service:

```python
import kfp

client = kfp.Client(host="http://localhost:3000")

print(client.list_experiments())
```


## Multi-user Kubeflow (from inside cluster)

To authenticate the Pipelines SDK from inside the cluster in multi-user mode, a [ServiceAccount token volume](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection) can be mounted to the Pod.
The ServiceAccount token is mounted onto the Pod by Kubernetes, then the Kubeflow Pipelines SDK uses this token to authenticate itself to the Kubeflow Pipelines API.

The following code creates a `kfp.Client()` using the ServiceAccount token mounted onto the Pod for authentication:

```python
import kfp

# the namespace in which you deployed Kubeflow Pipelines
namespace = "kubeflow"

# when `path` is None, the `KF_PIPELINES_SA_TOKEN_PATH` environment variable is used
# (if `KF_PIPELINES_SA_TOKEN_PATH` is unset, default is: `/var/run/secrets/kubeflow/pipelines/token`)
credentials = kfp.auth.ServiceAccountTokenVolumeCredentials(path=None)

client = kfp.Client(host=f"http://ml-pipeline-ui.{namespace}", credentials=credentials)

print(client.list_experiments())
```

### RBAC

The Kubeflow Pipelines API respects Kubernetes RBAC, and will check RoleBindings assigned to the ServiceAccount before allowing it to take Pipelines API actions.

This RoleBinding allows Pods with the `default-editor` ServiceAccount in `namespace-2` to manage Kubeflow Pipelines in `namespace-1`:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: allow-namespace-2-kubeflow-edit
  ## this RoleBinding is in `namespace-1`, because it grants access to `namespace-1`
  namespace: namespace-1
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kubeflow-edit
subjects:
  - kind: ServiceAccount
    name: default-editor
    ## the ServiceAccount lives in `namespace-2`
    namespace: namespace-2
```

{{% alert title="Tip" color="info" %}}
Review the ClusterRole called [aggregate-to-kubeflow-pipelines-edit](https://github.com/kubeflow/pipelines/blob/1e032f550ce23cd40bfb6827b995248537b07d08/manifests/kustomize/base/installs/multi-user/view-edit-cluster-roles.yaml#L36-L97) for a list of some important `pipelines.kubeflow.org` RBAC verbs.
{{% /alert %}}

{{% alert title="Tip" color="info" %}}
Kubeflow Notebooks pods run as the `default-editor` ServiceAccount by default, so RoleBindings for `default-editor` apply to them.
{{% /alert %}}

### Example Pod 

This Pod mounts a ServiceAccount token and sets the required `KF_PIPELINES_SA_TOKEN_PATH` environment variable:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: access-kfp-example
spec:
  containers:
  - image: hello-world:latest
    name: hello-world
    env:
      - ## this environment variable is automatically read by `kfp.Client()`
        name: KF_PIPELINES_SA_TOKEN_PATH
        ## this is the default value, but we show it here for clarity
        value: /var/run/secrets/kubeflow/pipelines/token
    volumeMounts:
      - mountPath: /var/run/secrets/kubeflow/pipelines
        name: volume-kf-pipeline-token
        readOnly: true
  volumes:
    - name: volume-kf-pipeline-token
      projected:
        sources:
          - serviceAccountToken:
              path: token
              expirationSeconds: 7200
              ## defined by the `TOKEN_REVIEW_AUDIENCE` environment variable on the `ml-pipeline` deployment
              audience: pipelines.kubeflow.org      
```

__Tips about the above `Pod` manifest:__

- the `kfp.Client()` reads the token from the path specified in the `KF_PIPELINES_SA_TOKEN_PATH` environment variable
  (default if unset: `/var/run/secrets/kubeflow/pipelines/token`)
- the correct `audience` must be used for the token, this is defined by the `TOKEN_REVIEW_AUDIENCE` environment variable on the `ml-pipeline` deployment
  (default if unset: `pipelines.kubeflow.org`)
- no additional setup is required to refresh tokens, refreshing is managed by Kubernetes itself

### Example PodDefault

You can use Kubeflow's [`PodDefaults`](https://github.com/kubeflow/kubeflow/tree/master/components/admission-webhook) to mount the required ServiceAccount token volume onto your Notebook Pod:

```yaml
apiVersion: kubeflow.org/v1alpha1
kind: PodDefault
metadata:
  name: access-ml-pipeline
  namespace: "<YOUR_USER_PROFILE_NAMESPACE>"
spec:
  desc: Allow access to Kubeflow Pipelines
  selector:
    matchLabels:
      access-ml-pipeline: "true"
  env:
    - ## this environment variable is automatically read by `kfp.Client()`
      name: KF_PIPELINES_SA_TOKEN_PATH
      ## this is the default value, but we show it here for clarity
      value: /var/run/secrets/kubeflow/pipelines/token
  volumes:
    - name: volume-kf-pipeline-token
      projected:
        sources:
          - serviceAccountToken:
              path: token
              expirationSeconds: 7200
              ## defined by the `TOKEN_REVIEW_AUDIENCE` environment variable on the `ml-pipeline` deployment
              audience: pipelines.kubeflow.org      
  volumeMounts:
    - mountPath: /var/run/secrets/kubeflow/pipelines
      name: volume-kf-pipeline-token
      readOnly: true
```

__Tips about the above `PodDefault` manifest:__

* `PodDefaults` are namespaced resources, so you need to create one inside __each__ of your Kubeflow `Profile` namespaces
* the Notebook Spawner UI will be aware of any `PodDefaults` in the user's namespace (they are selectable under the "configurations" section)


## Multi-user Kubeflow (from outside cluster)

The process to authenticate the Pipelines SDK from outside the cluster in multi-user mode will vary by distribution:

* [Kubeflow on Google Cloud](/docs/distributions/gke/pipelines/authentication-sdk/#connecting-to-kubeflow-pipelines-in-a-full-kubeflow-deployment)
* [Kubeflow on AWS](/docs/distributions/aws/pipeline/#authenticate-kubeflow-pipeline-using-sdk-outside-cluster)
* [Kubeflow on Azure](/docs/distributions/azure/authentication-oidc/#authenticate-kubeflow-pipelines-using-kubeflow-pipelines-sdk)
* [Kubeflow on IBM Cloud](/docs/distributions/ibm/pipelines/#2-authenticating-multi-user-kubeflow-pipelines-with-the-sdk)

### Example for Dex

For the deployments that use [Dex](https://dexidp.io/) as their identity provider, this example demonstrates how to authenticate the Pipelines SDK from outside the cluster.

First, expose your `istio-ingressgateway` service locally (if your Kubeflow Istio gateway is not already exposed on a domain):

```bash
# `svc/istio-ingressgateway` may be called something else, or use different ports
kubectl port-forward --namespace istio-system svc/istio-ingressgateway 8080:80
```

Second, this Python function will return a session cookie by authenticating with dex:

```python
import re
import requests
from urllib.parse import urlsplit

def get_istio_auth_session(url: str, username: str, password: str) -> dict:
    """
    Determine if the specified URL is secured by Dex and try to obtain a session cookie.
    WARNING: only Dex `staticPasswords` and `LDAP` authentication are currently supported
             (we default default to using `staticPasswords` if both are enabled)

    :param url: Kubeflow server URL, including protocol
    :param username: Dex `staticPasswords` or `LDAP` username
    :param password: Dex `staticPasswords` or `LDAP` password
    :return: auth session information
    """
    # define the default return object
    auth_session = {
        "endpoint_url": url,    # KF endpoint URL
        "redirect_url": None,   # KF redirect URL, if applicable
        "dex_login_url": None,  # Dex login URL (for POST of credentials)
        "is_secured": None,     # True if KF endpoint is secured
        "session_cookie": None  # Resulting session cookies in the form "key1=value1; key2=value2"
    }

    # use a persistent session (for cookies)
    with requests.Session() as s:

        ################
        # Determine if Endpoint is Secured
        ################
        resp = s.get(url, allow_redirects=True)
        if resp.status_code != 200:
            raise RuntimeError(
                f"HTTP status code '{resp.status_code}' for GET against: {url}"
            )

        auth_session["redirect_url"] = resp.url

        # if we were NOT redirected, then the endpoint is UNSECURED
        if len(resp.history) == 0:
            auth_session["is_secured"] = False
            return auth_session
        else:
            auth_session["is_secured"] = True

        ################
        # Get Dex Login URL
        ################
        redirect_url_obj = urlsplit(auth_session["redirect_url"])

        # if we are at `/auth?=xxxx` path, we need to select an auth type
        if re.search(r"/auth$", redirect_url_obj.path):

            ################
            # OPTION 1: default to "staticPasswords" auth type
            ################
            redirect_url_obj = redirect_url_obj._replace(
                path=re.sub(r"/auth$", "/auth/local", redirect_url_obj.path)
            )

            ################
            # OPTION 2: default to "ldap" auth type
            ################
            # redirect_url_obj = redirect_url_obj._replace(
            #     path=re.sub(r"/auth$", "/auth/ldap", redirect_url_obj.path)
            # )
            
        # if we are at `/auth/xxxx/login` path, then no further action is needed (we can use it for login POST)
        if re.search(r"/auth/.*/login$", redirect_url_obj.path):
            auth_session["dex_login_url"] = redirect_url_obj.geturl()

        # else, we need to be redirected to the actual login page
        else:
            # this GET should redirect us to the `/auth/xxxx/login` path
            resp = s.get(redirect_url_obj.geturl(), allow_redirects=True)
            if resp.status_code != 200:
                raise RuntimeError(
                    f"HTTP status code '{resp.status_code}' for GET against: {redirect_url_obj.geturl()}"
                )

            # set the login url
            auth_session["dex_login_url"] = resp.url

        ################
        # Attempt Dex Login
        ################
        resp = s.post(
            auth_session["dex_login_url"],
            data={"login": username, "password": password},
            allow_redirects=True
        )
        if len(resp.history) == 0:
            raise RuntimeError(
                f"Login credentials were probably invalid - "
                f"No redirect after POST to: {auth_session['dex_login_url']}"
            )

        # store the session cookies in a "key1=value1; key2=value2" string
        auth_session["session_cookie"] = "; ".join([f"{c.name}={c.value}" for c in s.cookies])

    return auth_session
```

Third, this Python code uses the above `get_istio_auth_session()` function to create a `kfp.Client()`:

```python
import kfp

KUBEFLOW_ENDPOINT = "http://localhost:8080"
KUBEFLOW_USERNAME = "user@example.com"
KUBEFLOW_PASSWORD = "12341234"

auth_session = get_istio_auth_session(
    url=KUBEFLOW_ENDPOINT,
    username=KUBEFLOW_USERNAME,
    password=KUBEFLOW_PASSWORD
)

client = kfp.Client(host=f"{KUBEFLOW_ENDPOINT}/pipeline", cookies=auth_session["session_cookie"])
print(client.list_experiments())
```


## Next Steps

* [Using the Kubeflow Pipelines SDK](/docs/components/pipelines/tutorials/sdk-examples/)
* [Kubeflow Pipelines SDK Reference](https://kubeflow-pipelines.readthedocs.io/en/stable/)
* [Experiment with the Kubeflow Pipelines API](/docs/components/pipelines/tutorials/api-pipelines/)
